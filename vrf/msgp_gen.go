package crypto

// Code generated by github.com/algorand/msgp DO NOT EDIT.

import (
	_ "unsafe"

	"github.com/algorand/msgp/msgp"
)

// The following msgp objects are implemented in this file:
// VRFSecrets
//      |-----> (*) MarshalMsg
//      |-----> (*) CanMarshalMsg
//      |-----> (*) UnmarshalMsg
//      |-----> (*) CanUnmarshalMsg
//      |-----> (*) Msgsize
//      |-----> (*) MsgIsZero
//      |-----> VRFSecretsMaxSize()
//
// VrfOutput
//     |-----> (*) MarshalMsg
//     |-----> (*) CanMarshalMsg
//     |-----> (*) UnmarshalMsg
//     |-----> (*) CanUnmarshalMsg
//     |-----> (*) Msgsize
//     |-----> (*) MsgIsZero
//     |-----> VrfOutputMaxSize()
//
// VrfPrivkey
//      |-----> (*) MarshalMsg
//      |-----> (*) CanMarshalMsg
//      |-----> (*) UnmarshalMsg
//      |-----> (*) CanUnmarshalMsg
//      |-----> (*) Msgsize
//      |-----> (*) MsgIsZero
//      |-----> VrfPrivkeyMaxSize()
//
// VrfProof
//     |-----> (*) MarshalMsg
//     |-----> (*) CanMarshalMsg
//     |-----> (*) UnmarshalMsg
//     |-----> (*) CanUnmarshalMsg
//     |-----> (*) Msgsize
//     |-----> (*) MsgIsZero
//     |-----> VrfProofMaxSize()
//
// VrfPubkey
//     |-----> (*) MarshalMsg
//     |-----> (*) CanMarshalMsg
//     |-----> (*) UnmarshalMsg
//     |-----> (*) CanUnmarshalMsg
//     |-----> (*) Msgsize
//     |-----> (*) MsgIsZero
//     |-----> VrfPubkeyMaxSize()
//

// MarshalMsg implements msgp.Marshaler
func (z *VRFSecrets) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "PK"
	o = append(o, 0x82, 0xa2, 0x50, 0x4b)
	o = msgp.AppendBytes(o, ((*z).PK)[:])
	// string "SK"
	o = append(o, 0xa2, 0x53, 0x4b)
	o = msgp.AppendBytes(o, ((*z).SK)[:])
	return
}

func (_ *VRFSecrets) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*VRFSecrets)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *VRFSecrets) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0003 int
	var zb0004 bool
	zb0003, zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0003, zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = msgp.ReadExactBytes(bts, ((*z).PK)[:])
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "PK")
				return
			}
		}
		if zb0003 > 0 {
			zb0003--
			bts, err = msgp.ReadExactBytes(bts, ((*z).SK)[:])
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "SK")
				return
			}
		}
		if zb0003 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0003)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0004 {
			(*z) = VRFSecrets{}
		}
		for zb0003 > 0 {
			zb0003--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "PK":
				bts, err = msgp.ReadExactBytes(bts, ((*z).PK)[:])
				if err != nil {
					err = msgp.WrapError(err, "PK")
					return
				}
			case "SK":
				bts, err = msgp.ReadExactBytes(bts, ((*z).SK)[:])
				if err != nil {
					err = msgp.WrapError(err, "SK")
					return
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *VRFSecrets) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*VRFSecrets)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *VRFSecrets) Msgsize() (s int) {
	s = 1 + 3 + msgp.ArrayHeaderSize + (32 * (msgp.ByteSize)) + 3 + msgp.ArrayHeaderSize + (64 * (msgp.ByteSize))
	return
}

// MsgIsZero returns whether this is a zero value
func (z *VRFSecrets) MsgIsZero() bool {
	return ((*z).PK == (VrfPubkey{})) && ((*z).SK == (VrfPrivkey{}))
}

// MaxSize returns a maximum valid message size for this message type
func VRFSecretsMaxSize() (s int) {
	s = 1 + 3
	// Calculating size of array: z.PK
	s += msgp.ArrayHeaderSize + ((32) * (msgp.ByteSize))
	s += 3
	// Calculating size of array: z.SK
	s += msgp.ArrayHeaderSize + ((64) * (msgp.ByteSize))
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *VrfOutput) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendBytes(o, (*z)[:])
	return
}

func (_ *VrfOutput) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*VrfOutput)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *VrfOutput) UnmarshalMsg(bts []byte) (o []byte, err error) {
	bts, err = msgp.ReadExactBytes(bts, (*z)[:])
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	o = bts
	return
}

func (_ *VrfOutput) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*VrfOutput)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *VrfOutput) Msgsize() (s int) {
	s = msgp.ArrayHeaderSize + (64 * (msgp.ByteSize))
	return
}

// MsgIsZero returns whether this is a zero value
func (z *VrfOutput) MsgIsZero() bool {
	return (*z) == (VrfOutput{})
}

// MaxSize returns a maximum valid message size for this message type
func VrfOutputMaxSize() (s int) {
	// Calculating size of array: z
	s = msgp.ArrayHeaderSize + ((64) * (msgp.ByteSize))
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *VrfPrivkey) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendBytes(o, (*z)[:])
	return
}

func (_ *VrfPrivkey) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*VrfPrivkey)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *VrfPrivkey) UnmarshalMsg(bts []byte) (o []byte, err error) {
	bts, err = msgp.ReadExactBytes(bts, (*z)[:])
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	o = bts
	return
}

func (_ *VrfPrivkey) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*VrfPrivkey)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *VrfPrivkey) Msgsize() (s int) {
	s = msgp.ArrayHeaderSize + (64 * (msgp.ByteSize))
	return
}

// MsgIsZero returns whether this is a zero value
func (z *VrfPrivkey) MsgIsZero() bool {
	return (*z) == (VrfPrivkey{})
}

// MaxSize returns a maximum valid message size for this message type
func VrfPrivkeyMaxSize() (s int) {
	// Calculating size of array: z
	s = msgp.ArrayHeaderSize + ((64) * (msgp.ByteSize))
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *VrfProof) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendBytes(o, (*z)[:])
	return
}

func (_ *VrfProof) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*VrfProof)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *VrfProof) UnmarshalMsg(bts []byte) (o []byte, err error) {
	bts, err = msgp.ReadExactBytes(bts, (*z)[:])
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	o = bts
	return
}

func (_ *VrfProof) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*VrfProof)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *VrfProof) Msgsize() (s int) {
	s = msgp.ArrayHeaderSize + (80 * (msgp.ByteSize))
	return
}

// MsgIsZero returns whether this is a zero value
func (z *VrfProof) MsgIsZero() bool {
	return (*z) == (VrfProof{})
}

// MaxSize returns a maximum valid message size for this message type
func VrfProofMaxSize() (s int) {
	// Calculating size of array: z
	s = msgp.ArrayHeaderSize + ((80) * (msgp.ByteSize))
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *VrfPubkey) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendBytes(o, (*z)[:])
	return
}

func (_ *VrfPubkey) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*VrfPubkey)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *VrfPubkey) UnmarshalMsg(bts []byte) (o []byte, err error) {
	bts, err = msgp.ReadExactBytes(bts, (*z)[:])
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	o = bts
	return
}

func (_ *VrfPubkey) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*VrfPubkey)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *VrfPubkey) Msgsize() (s int) {
	s = msgp.ArrayHeaderSize + (32 * (msgp.ByteSize))
	return
}

// MsgIsZero returns whether this is a zero value
func (z *VrfPubkey) MsgIsZero() bool {
	return (*z) == (VrfPubkey{})
}

// MaxSize returns a maximum valid message size for this message type
func VrfPubkeyMaxSize() (s int) {
	// Calculating size of array: z
	s = msgp.ArrayHeaderSize + ((32) * (msgp.ByteSize))
	return
}
